from pythonping import ping
import nmap
from ftplib import FTP, error_perm, error_reply, error_temp
import os
import requests
import socket
import re
import smbclient
import subprocess
import urllib3
import multiprocessing
from chardet.universaldetector import UniversalDetector
import threading
from sys import argv
from binaryornot.check import is_binary


def telechargement_et_test_upload_serveur_SMB(connexion_partage_SMB, serveur_SMB_distant, nom_partage):
    try:
        liste_dossier_partage_smb = ["/"]

        for dossier in liste_dossier_partage_smb:
            for element in (connexion_partage_SMB.listdir(dossier)):
                if (connexion_partage_SMB.exists(dossier + element + "/")) == True:
                    liste_dossier_partage_smb.append(dossier + element + "/")
        try:
            os.mkdir(serveur_SMB_distant + "-SMB/" + nom_partage)
        except:
            print("Le dossier %s-SMB/%s existe déjà" % (serveur_SMB_distant, nom_partage))

        for dossier in liste_dossier_partage_smb:
            if dossier != "/":
                try:
                    os.mkdir(serveur_SMB_distant + "-SMB/" + nom_partage + "/" + dossier)
                except:
                    print("Le dossier %s-SMB/%s/%s existe déjà" % (serveur_SMB_distant, nom_partage, dossier))

            # Test Upload de Dossier
            try:
                connexion_partage_SMB.upload("test_upload_SMB.txt", dossier + "/test_upload_SMB.txt")
                print("Upload de fichier réussi dans le dossier %s du partage SMB %s du serveur %s ! " % (dossier, nom_partage,serveur_SMB_distant))
            except:
                print("Impossible d'envoyer un fichier dans le dossier %s du partage SMB %s du serveur %s" % (dossier, nom_partage,serveur_SMB_distant))

            for element in (connexion_partage_SMB.listdir(dossier)):
                try:
                    if dossier != "/":
                        connexion_partage_SMB.download(dossier + element,
                                                       serveur_SMB_distant + "-SMB/" + nom_partage + "/" + dossier + "/" + element)
                    else:
                        connexion_partage_SMB.download(dossier + element,
                                                       serveur_SMB_distant + "-SMB/" + nom_partage + "/" + element)
                except smbclient.SambaClientError:
                    print("Téléchargement du dossier %s depuis le serveur SMB %s en cours" % (
                    element, serveur_SMB_distant))

        is_function_suceeded = True
        return is_function_suceeded
    except smbclient.SambaClientError:
        is_function_suceeded = False
        return is_function_suceeded


def analyse_SMB(serveur_SMB):
    # LISTING DES PARTAGES SMB


    message_smbclient = subprocess.getstatusoutput("/usr/bin/smbclient -L " + serveur_SMB + " -N")

    if message_smbclient[0] == 1:
        print("Impossible d'afficher la liste des partages SMB du serveur %s sans identifiant" % serveur_SMB)
        return 0

    sortie_smbclient = message_smbclient[1].split("\n")

    del sortie_smbclient[0:4]

    print("Voici la liste des partages SMB du serveur %s visibles sans identifiant :" % serveur_SMB)

    liste_Partage_SMB = []

    for ligne_sortie_smbclient in sortie_smbclient:
        if "Disk" in ligne_sortie_smbclient:
            longueur_nom_partage_SMB = ligne_sortie_smbclient.find(" ")
            liste_Partage_SMB.append(ligne_sortie_smbclient[1:longueur_nom_partage_SMB])

    print(liste_Partage_SMB)

    try:
        os.mkdir(serveur_SMB + "-SMB")
    except:
        print("Le dossier %s-SMB existe déjà" % serveur_SMB)

    fichier_test_upload = open("test_upload_SMB.txt", "w")
    fichier_test_upload.write("Test upload de fichier vers serveur SMB")
    fichier_test_upload.close()

    # Connexion aux différents partages SMB
    for partage_SMB in liste_Partage_SMB:

        connexion_smb = smbclient.SambaClient(server=serveur_SMB, share=partage_SMB, username="anonymous", password="")
        is_function_succeeded = telechargement_et_test_upload_serveur_SMB(connexion_smb, serveur_SMB, partage_SMB)

        if is_function_succeeded == False:

            connexion_smb = smbclient.SambaClient(server=serveur_SMB, share=partage_SMB, username="", password="")
            is_function_succeeded = telechargement_et_test_upload_serveur_SMB(connexion_smb, serveur_SMB, partage_SMB)

            if is_function_succeeded == False:
                print("Impossible de se connecter au partage SMB %s du serveur %s sans identifiant" % (partage_SMB,serveur_SMB))

    print(
        "Le contenu de tous les partages SMB du serveur %s accessibles sans identifiant ont été téléchargés dans le dossier %s-SMB" % (
            serveur_SMB, serveur_SMB))
    os.remove("test_upload_SMB.txt")


def analyse_FTP(serveurFTP):


    connexion_FTP = FTP(serveurFTP)
    try:
        connexion_FTP.login()
        print("Connexion FTP possible sur le serveur FTP %s avec le compte anonymous !" % serveurFTP)
        contenu_FTP = connexion_FTP.dir()
        print("Voici les dossiers et fichiers stockés à la racine du serveur FTP %s : " % serveurFTP)
        print(contenu_FTP)

        try:
            os.mkdir("%s-FTP" % serveurFTP)
        except:
            print(
                "Les fichiers du serveur FTP accessibles depuis le compte anonymous seront stockés dans le dossier %s-FTP déjà présent" % serveurFTP)

        liste_dossier_serveur_FTP = ["/"]

        for dossier in liste_dossier_serveur_FTP:
            connexion_FTP.cwd(dossier)
            for element in connexion_FTP.nlst():
                try:
                    connexion_FTP.cwd(element)
                    liste_dossier_serveur_FTP.append(dossier + element + "/")
                    connexion_FTP.cwd(dossier)
                except:
                    print("issou")

        # CETTE BOUCLE PERMET DE TELECHARGER TOUS LES FICHIERS STOCKES SUR LE SERVEUR FTP (UNIQUEMENT CEUX STOCKES A LA RACINE POUR LE MOMENT)
        for file in connexion_FTP.nlst():
            # AJOUTER LA DETECTION DE DOSSIERS + TELECHARGEMENT DU CONTENU DE CES DOSSIERS
            try:
                connexion_FTP.retrbinary('RETR ' + file, open(serveurFTP + "-FTP/" + file, 'wb').write)
            except error_perm:
                print("Le fichier %s ne peut être téléchargé avec le compte anonymous" % file)

        fichier_test_upload = open("test_FTP.txt", "w")
        fichier_test_upload.write("Test Serveur FTP")

        # AJOUTER LE TEST D'ENVOI DE FICHIERS DANS CHACUN DES DOSSIERS
        for dossier in liste_dossier_serveur_FTP:
            connexion_FTP.cwd(dossier)
            try:
                connexion_FTP.storbinary('STOR test_FTP.txt', fichier_test_upload)
                connexion_FTP.delete("test_FTP.txt")
            except error_perm:
                print("Impossible d'envoyer un fichier dans le dossier %s du serveur FTP %s" % (dossier, serveurFTP))

        connexion_FTP.quit()
        fichier_test_upload.close()
        os.remove("test_FTP.txt")


        print(
            "Scan FTP du serveur %s terminé. Les fichiers ayant pu être téléchargés sont stockés dans le dossier %s-FTP" % (
                serveurFTP, serveurFTP))


    except error_perm:
        print("Connexion FTP impossible sur le serveur %s avec le compte anonymous !" % serveurFTP)


    except  :
        print("Echec lors de la communication avec le serveur FTP %s !" % serveurFTP)


def analyse_formulaire_php(serveur, protocole, port, page):


    requete_formulaire = requests.get(protocole + serveur + ":" + str(port) + page)
    LISTE_HEADERS_A_IGNORER = ["Date", "Server", "Vary", "Content-Encoding", "Content-Length", "Keep-Alive",
                               "Connection", "Content-Type"]

    dictionnaire_headers = dict(requete_formulaire.headers.copy())

    for header, valeur_header in dictionnaire_headers.items():
        if header not in LISTE_HEADERS_A_IGNORER:
            print("En-Tête HTTP %s : %s " % (header, valeur_header))

    dictionnaire_parametre_formulaire = {}

    # Penser à implémenter l'analyse des headers intéressants (c'est à dire ceux qui ne sont pas présents de base dans le protocole HTTP)
    if "<form" in requete_formulaire.text:
        nb_arguments_formulaire = 0
        for line in requete_formulaire.iter_lines():
            if "input" in str(line) and 'type="submit"' not in str(line):
                nb_arguments_formulaire = nb_arguments_formulaire + 1

                type_parametre = re.findall(r'<input type=\W(\w+)\W', str(line))
                nom_parametre = re.findall(r'name=\W(\w+)\W', str(line))

                if len(nom_parametre) == 0 :
                    dictionnaire_parametre_formulaire["void"] = type_parametre[0]
                else :
                    dictionnaire_parametre_formulaire[nom_parametre[0]] = type_parametre[0]

        methode_formulaire = re.findall(r'method=\W(\w+)\W', requete_formulaire.text)
        print("Le formulaire de la page %s du serveur %s nécessite %d paramètres et est envoyé grâce à la méthode %s" % (
            page, serveur, nb_arguments_formulaire, methode_formulaire[0]))
        print("Voici la liste de ces paramètres :")
        for nom, type_param in dictionnaire_parametre_formulaire.items():
            print("Nom : %s , type : %s" % (nom, type_param))

def brute_force_http(serveur, protocole, port, wordlist, dossier, liste_extensions, numero_processus, lignes_a_lire,
                     encodage, methode, dictionnaire_fichier, dictionnaire_dossier, liste_directory_indexing):
    debut_brute_force = numero_processus * lignes_a_lire
    if debut_brute_force != 0:
        debut_brute_force = debut_brute_force + 1

    with open(wordlist, encoding=encodage, mode='r') as liste_mots:
        lignes_traitees = liste_mots.readlines()[debut_brute_force:(debut_brute_force + lignes_a_lire)]

        gestion_http = urllib3.PoolManager()
        for line in lignes_traitees:
            for extension in liste_extensions:
                test_requete = gestion_http.request(methode, protocole + serveur + ":" + str(port) + dossier + line[
                                                                                                               :-1] + extension)
                if test_requete.status != 404:
                    if ".htaccess" != line[:-1] and ".htpasswd" != line[:-1]:
                        dictionnaire_fichier[(dossier + line[:-1] + extension)] = test_requete.status
                        print(
                            protocole + serveur + ":" + str(port) + dossier + line[:-1] + extension + "         " + str(
                                test_requete.status))

            test_requete = gestion_http.request(methode,protocole + serveur + ":" + str(port) + dossier + line[:-1] + "/")
            if test_requete.status != 404:
                # TEST POUR SAVOIR SI LE DIRECTORY INDEXING EST ACTIVE
                test_requete = gestion_http.request("GET",
                                                    protocole + serveur + ":" + str(port) + dossier + line[:-1] + "/")
                if (str(test_requete.data).__len__()) > 3 and ".htaccess" != line[:-1] and ".htpasswd" != line[
                                                                                                          :-1] and test_requete.status == 200:
                    print(protocole + serveur + ":" + str(port) + dossier + line[
                                                                            :-1] + "/" + " : Directory Indexing activé")
                    liste_directory_indexing.append((dossier + line[:-1]))

                elif ".htaccess" != line[:-1] and ".htpasswd" != line[:-1] :
                    dictionnaire_dossier[(dossier + line[:-1])] = test_requete.status
                    print(protocole + serveur + ":" + str(port) + dossier + line[:-1] + "/" + "         " + str(
                        test_requete.status))


def analyse_HTTP(serveurHTTP, protocole_serveur, port_serveur, wordlist_bruteforce, extensions_a_bruteforcer,
                 nb_processus):

    liste_dossiers_a_powned = ["/"]
    liste_dossiers_deja_testes = []

    protocole_serveur = protocole_serveur + "://"
    contenu_robots_txt = requests.get(protocole_serveur + serveurHTTP + "/robots.txt")
    if contenu_robots_txt.status_code == 200:
        print("Contenu du fichier robots.txt du serveur %s :" % serveurHTTP)
        for line in (contenu_robots_txt.iter_lines()):
            if "Disallow:" in str(line):
                ligne_robots_string = str(line)
                fichier_ou_dossier_robot = ligne_robots_string[(ligne_robots_string.find("/")):(ligne_robots_string.rfind("'"))]
                print (fichier_ou_dossier_robot)
                if "." not in fichier_ou_dossier_robot or "/" in fichier_ou_dossier_robot :
                    test_requete = requests.get(protocole_serveur + serveurHTTP + fichier_ou_dossier_robot + "/")
                    if test_requete.status_code != 404 and fichier_ou_dossier_robot[-1] == "/" :
                        liste_dossiers_a_powned.append(fichier_ou_dossier_robot)
                    else:
                        liste_dossiers_a_powned.append(fichier_ou_dossier_robot + "/" )
    else:
        print("Le serveur %s ne contient pas de fichier robots.txt" % serveurHTTP)


    verification_gestion_fichier_non_present = requests.get(
        protocole_serveur + serveurHTTP + ":" + str(port_serveur) + "/TESTERREUR404_ElTito.php")
    if verification_gestion_fichier_non_present.status_code != 404:
        print("Le serveur %s ne retourne pas d'erreur 404 si on essaye d'accéder à un fichier inexistant" % serveurHTTP)
        exit(0)

    verification_methode_http = requests.head(protocole_serveur + serveurHTTP + ":" + str(port_serveur))
    if verification_methode_http.status_code != 405:
        methode_http_a_utiliser = "HEAD"
    else:
        methode_http_a_utiliser = "GET"

    nb_lignes_wordlist = 0

    detection_encodage = UniversalDetector()
    detection_encodage.reset()

    with open(wordlist_bruteforce, mode='rb') as e:
        for b in e:
            detection_encodage.feed(b)
            if detection_encodage.done:
                break
    detection_encodage.close()

    encodage_wordlist = detection_encodage.result["encoding"]

    with open(wordlist_bruteforce, encoding=encodage_wordlist) as f:
        for line in f:
            nb_lignes_wordlist = nb_lignes_wordlist + 1

    nb_lignes_a_lire_par_processus = nb_lignes_wordlist // nb_processus

    manager = multiprocessing.Manager()
    dictionnaire_fichier_decouverts = manager.dict()
    dictionnare_dossiers_decouverts = manager.dict()
    liste_dossier_directory_indexing = manager.list()

    while (len(liste_dossiers_a_powned)) > 0:

        jobs = []

        for i in range(nb_processus):
            tache = multiprocessing.Process(target=brute_force_http, args=(
                serveurHTTP, protocole_serveur, port_serveur, wordlist_bruteforce, liste_dossiers_a_powned[0],
                extensions_a_bruteforcer, i, nb_lignes_a_lire_par_processus, encodage_wordlist, methode_http_a_utiliser,
                dictionnaire_fichier_decouverts, dictionnare_dossiers_decouverts, liste_dossier_directory_indexing))
            jobs.append(tache)
            tache.start()

        for proc in jobs:
            proc.join()

        liste_dossiers_deja_testes.append(liste_dossiers_a_powned[0])

        for dossier in dictionnare_dossiers_decouverts.keys():
            if ".htpasswd" in dossier or ".htaccess" in dossier:
                dictionnaire_fichier_decouverts[dossier] = dictionnare_dossiers_decouverts.get(dossier)
                del dictionnare_dossiers_decouverts[dossier]
            elif dossier == "/server-status":
                dictionnaire_fichier_decouverts[dossier] = dictionnare_dossiers_decouverts.get(dossier)
                del dictionnare_dossiers_decouverts[dossier]
            elif (dossier + "/") not in liste_dossiers_deja_testes and (dossier + "/") not in liste_dossiers_a_powned:
                liste_dossiers_a_powned.append(dossier + "/")

        liste_dossiers_a_powned.remove(liste_dossiers_a_powned[0])


    print(dictionnaire_fichier_decouverts)
    print(dictionnare_dossiers_decouverts)
    print(liste_dossier_directory_indexing)

    for page,message_retour in dictionnaire_fichier_decouverts.items():
        print(page)
        print(message_retour)
        if ".php" in page or ".aspx" in page and message_retour == "200" :
            analyse_formulaire_php(serveurHTTP, protocole_serveur, port_serveur, page)


def analyse_version_services(liste,serveur):


    for service_port in liste:
        if len(service_port) > 1 :
            liste_exploits_service = subprocess.getoutput("/usr/bin/searchsploit " + service_port)
            if "Exploits: No Result" in liste_exploits_service and "Shellcodes: No Result" in liste_exploits_service :
                print("Aucun exploit pour le service %s installé sur le serveur %s n'est disponible sur exploit-db" % (service_port,serveur) )
            else :
                print("Voici les exploits disponibles sur exploit-db pour le service %s installé sur le serveur %s" %(service_port,serveur) )
                print(liste_exploits_service)


def scan_ports_ouverts(machine_distante, protocole_a_scanner, option_vitesse_scan, wordlist_web,
                       liste_extensions_enumeration_HTTP, nb_processus_enum_HTTP):
    if protocole_a_scanner == "TCP":
        argumentNMAP = "-p- -sV " + str(option_vitesse_scan)
    else:
        argumentNMAP = "-sU -F -sV " + str(option_vitesse_scan)

    scanMachine = nmap.PortScanner()

    liste_service_en_cours = []
    dictionnaire_service = {}

    scanMachine.scan(machine_distante, arguments=argumentNMAP)

    adresse_IP_machine = socket.gethostbyname(machine_distante)

    print ("Voici les ports %s ouverts sur la machine %s :" %(protocole_a_scanner,machine_distante) )
    for protocole in scanMachine[adresse_IP_machine].all_protocols():
        liste_port = scanMachine[adresse_IP_machine][protocole].keys()
        for port in liste_port:
            service_port = scanMachine[machine_distante][protocole][port]['product'] + " " + \
                           scanMachine[machine_distante][protocole][port]['version']

            print('  port : %s %s \tetat : %s \t%s' % (
                port, protocole, scanMachine[adresse_IP_machine][protocole][port]['state'], service_port))

            liste_service_en_cours.append(service_port)
            dictionnaire_service[port] = scanMachine[machine_distante][protocole][port]['name']


    liste_service_en_cours = list(set(liste_service_en_cours))
    analyse_version_services(liste_service_en_cours,machine_distante)


    is_smb_already_scanned = False
    is_http_already_scanned = False

    for port_dico, service in dictionnaire_service.items():

        if service == "ftp" and (scanMachine[adresse_IP_machine][protocole][port_dico]['state']) == "open":

            thread_analyse_protocole = threading.Thread(target=analyse_FTP, args=(machine_distante,))
            thread_analyse_protocole.start()

        elif service == "http" and (scanMachine[adresse_IP_machine][protocole][port_dico]['state']) == "open" and is_http_already_scanned == False:

            thread_analyse_protocole = threading.Thread(target=analyse_HTTP, args=(machine_distante, service, port_dico,
                                                                                   wordlist_web,
                                                                                   liste_extensions_enumeration_HTTP,
                                                                                   nb_processus_enum_HTTP))
            thread_analyse_protocole.start()
            is_http_already_scanned = True

        elif scanMachine[adresse_IP_machine][protocole][port_dico]["name"] == "netbios-ssn" and (
                scanMachine[adresse_IP_machine][protocole][port_dico]['state']) == "open" and is_smb_already_scanned == False:

            thread_analyse_protocole = threading.Thread(target=analyse_SMB, args=(machine_distante,))
            thread_analyse_protocole.start()

            is_smb_already_scanned = True

def main():
    if (len(argv) != 7 or argv[1] == "-h" or argv[1] == "--help"):
        print(
            "Ce script doit s'exécuter de la manière suivante : Adresse_IP,Hostname protocole_scan-vitesse-nmap(de 1 à 5) wordlist-enumeration-HTTP nb_processus_HTTP extensionsHTTP(.php,.txt)")
        exit(1)

    liste_machines = argv[1].split(",")
    protocole_utilise = argv[2]
    try:
        vitesse_nmap = int(argv[3])
    except:
        print("L'option -T de nmap correspond toujours à un entier entre 1 et 5 !")
        exit(1)

    wordlist_enumeration_HTTP = argv[4]

    try:
        nb_processus_HTTP = int(argv[5])
    except:
        print("Le nombre de processus doit être un entier compris entre 1 et 100")
        exit(1)

    liste_extensions_HTTP = argv[6].split(",")

    for machine in liste_machines:
        try:
            if "Request timed out" in str(ping(machine)):
                print("Communication impossible avec la machine %s" % machine)
                exit(1)
        except:
            print("L'adresse IP %s est incorrecte !" % machine)
            exit(1)

    if protocole_utilise != "TCP" and protocole_utilise != "UDP" and protocole_utilise != "TCP/UDP":
        print("Le protocole de scan utilisé doit être TCP, UDP ou TCP/UDP !")
        exit(1)

    if vitesse_nmap not in range(1, 6):
        print("L'option -T de nmap correspond toujours à un entier entre 1 et 5 !")
        exit(1)

    if os.path.exists(wordlist_enumeration_HTTP):
        if is_binary(wordlist_enumeration_HTTP):
            print("Le fichier %s n'est pas un fichier texte" % wordlist_enumeration_HTTP)
            exit(1)
    else:
        print("Le fichier %s n'existe pas" % wordlist_enumeration_HTTP)
        exit(1)

    if nb_processus_HTTP not in range(1, 101):
        print("Le nombre de processus doit être un entier compris entre 1 et 100")
        exit(1)

    i = 0

    for extension in liste_extensions_HTTP:
        if extension[0] != ".":
            liste_extensions_HTTP[i] = "." + extension
            extension = "." + extension
        extension_sans_point = extension[1:]
        if not extension_sans_point.isalnum():
            print("L'extension %s n'est pas alphanumérique !" % extension)
            exit(1)

    if not os.path.exists("/usr/bin/searchsploit") or not os.path.exists("/usr/bin/nmap") or not os.path.exists("/usr/bin/smbclient")  :
        print("Les 3 paquets suivants doivent être installés pour permettre l'exécution de ce script : nmap, smbclient et searchsploit")
        exit(0)

    liste_processus = []

    for machine in liste_machines:
        if protocole_utilise != "TCP/UDP":
            tache = multiprocessing.Process(target=scan_ports_ouverts, args=(machine, protocole_utilise,
                                                                             vitesse_nmap, wordlist_enumeration_HTTP,
                                                                             liste_extensions_HTTP, nb_processus_HTTP))
            liste_processus.append(liste_processus)
            tache.start()

        elif protocole_utilise == "TCP/UDP":
            tache = multiprocessing.Process(target=scan_ports_ouverts, args=(machine, "TCP", vitesse_nmap,
                                                                             wordlist_enumeration_HTTP,
                                                                             liste_extensions_HTTP, nb_processus_HTTP))
            liste_processus.append(liste_processus)
            tache.start()

            tache = multiprocessing.Process(target=scan_ports_ouverts, args=(machine, "UDP", vitesse_nmap,
                                                                             wordlist_enumeration_HTTP,
                                                                             liste_extensions_HTTP, nb_processus_HTTP))
            liste_processus.append(liste_processus)
            tache.start()

if __name__ == "__main__":
    main()
